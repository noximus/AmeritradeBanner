MovieClip.prototype.tween = function (prop, propDest, timeSeconds, animType, delay, callback, extra1, extra2) {  // Sets default values if undefined/invalid  if (timeSeconds < 0.001) timeSeconds = 2; // default time length  if (animType == undefined || animType == "") animType = "easeOutExpo"; // default equation!  if (delay == undefined) delay = 0; // default delay  // Starts tweening.. prepares to create handling mcs  if (typeof(prop) == "string") {    // Single property    var properties = [prop]; // Properties, as in "_x"    var oldProperties = [this[prop]]; // Old value, as in 0    var newProperties = [propDest]; // New (target) value, as in 100  } else {    // Array of properties    var properties = []; // Properties, as in "_x"    var oldProperties = []; // Old value, as in 0    var newProperties = []; // New (target) value, as in 100    for (var i in prop) oldProperties.push (this[prop[i]]);    for (var i in prop) properties.push (prop[i]);    for (var i in propDest) newProperties.push (propDest[i]);  }  var $_callback_assigned = false; // 1.7.4: Knows if callback has already been assigned to a movieclip  // Checks if the master movieClip (which controls all tweens) exists  if (_root.__tweenController__ == undefined) {    // Doesn't exist: create, and set its methods/data    var tweenHolder = _root.createEmptyMovieClip ("__tweenController__", 123432); // Any level    tweenHolder.$_tweenPropList = new Array();  // Will hold the list of properties beeing tweened. an array of objects.    tweenHolder.$_tTime = getTimer();    tweenHolder.onEnterFrame = function() {      // On each pass, it should check and update the properties      var tTime = this.$_tTime = getTimer();      for (var i=0; i<this.$_tweenPropList.length; i++) {        var objProp = this.$_tweenPropList[i]; // Temporary shortcut to this property controller object        if (objProp._timeStart + (objProp._delay*1000) <= tTime) {          // Starts tweening already          if (objProp._timeDest + (objProp._delay*1000) <= tTime) {            // Past the destiny time: ended.            // Set it to its final value to make sure            // there are no discrepancies            objProp._targ[objProp._prop] = objProp._propDest;            // Removes from the tweening properties list array. So simpler than the previous versions :)            // (objProp still exists so it works further on)            this.$_tweenPropList.splice(i,1);            i--;            objProp._targ.$_tweenCount--;            if (objProp._targ.$_tweenCount == 0) delete objProp._targ.$_tweenCount;                        if (objProp._callback != undefined) {              // Calls the _callback function              if (_global.backwardCallbackTweening) {                // Old style, for compatibility.                // IF YOU'RE USING AN OLD VERSION AND WANT BACKWARD COMPATIBILITY, use this line:                // _global.backwardCallbackTweening = true;                // ON YOUR MOVIES AFTER (or before) THE #INCLUDE STATEMENT.                var childMC = objProp._targ.createEmptyMovieClip("__child__", 122344);                objProp._callback.apply(childMC, null);                childMC.removeMovieClip();              } else {                // New method for 2.12.9: use the mc scope                // So simpler. I should have done this from the start...                // ...instead of trying the impossible (using the scope from which the tween was called)                objProp._callback.apply(objProp._targ, null);              }            }            // Deletes the tweener movieclip if no tweens are left            if (this.$_tweenPropList.length == 0) this.removeMovieClip();          } else {            // Continue, simply set the correct property value.            if (objProp._propStart == undefined) objProp._propStart = objProp._targ[objProp._prop]; // "first-time" update to allow dinamically changed values for delays (2.14.9)            objProp._targ[objProp._prop] = _global.findTweenValue (objProp._propStart, objProp._propDest, objProp._timeStart, tTime-(objProp._delay*1000), objProp._timeDest, objProp._animType, objProp._extra1, objProp._extra2);            if (typeof(objProp._targ) != "movieclip" && (objProp._prop == "__special_text_b__")) {              // Special case: textfield, B value for textColor value. B being the last one to update, so also set the textfield's textColor              objProp._targ.textColor = (objProp._targ.__special_text_r__ << 16) + (objProp._targ.__special_text_g__ << 8) + objProp._targ.__special_text_b__;            }          }        }      }    };  }  var tweenPropList = _root.__tweenController__.$_tweenPropList;  // Now set its data (adds to the list of properties being tweened)  var tTime = _root.__tweenController__.$_tTime; // 2.16.12: laco's suggestion, for a REAL uniform time  for (var i in oldProperties) {    // Set one new object for each property that should be tweened    if (newProperties[i] != undefined && !this.$_isTweenLocked) {      // Only creates tweenings for properties that are not undefined. That way,      // certain properties can be optional on the shortcut functions even though      // they are passed to the tweening function      // Checks if it's at the tween list already      if (this.$_tweenCount > 0) {        for (var pti=0; pti<tweenPropList.length; pti++) {          if (tweenPropList[pti]._targ == this && tweenPropList[pti]._prop == properties[i]) {            // Exists for the same property... checks if the time is the same (if the NEW's start time would be before the OLD's ending time)            if (tTime + (delay*1000) < tweenPropList[pti]._timeDest) {              // It's a property that is already being tweened, BUT has already started, so it's ok to overwrite.              // So it deletes the old one(s) and THEN creates the new one.              tweenPropList.splice(pti, 1);              pti--;              this.$_tweenCount--;            }          }        }      }      // Finally, adds the new tween data to the list      tweenPropList.push ({        _prop : properties[i],        _targ : this,        _propStart : undefined, // was "oldProperties[i]" (2.14.9). Doesn't set: it must be read at the first update time, to allow animating with correct [new] values when using the delay parameter        _propDest : newProperties[i],        _timeStart : tTime,        _timeDest : tTime+(timeSeconds*1000),        _animType : animType,        _extra1 : extra1,        _extra2 : extra2,        _delay : delay,        _callback : $_callback_assigned ? undefined : callback      });      // $tweenCount is used for a faster start      this.$_tweenCount = this.$_tweenCount > 0 ? this.$_tweenCount+1 : 1; // to avoid setting ++ to undefined      $_callback_assigned = true; // 1.7.4    }  }    // Hides stuff from public view on the movieclip being tweened  ASSetPropFlags(this, "$_tweenCount", 1, 0); // List of stuff being tweened};ASSetPropFlags(MovieClip.prototype, "tween", 1, 0);_global.findTweenValue = function (_propStart, _propDest, _timeStart, _timeNow, _timeDest, _animType, _extra1, _extra2) {  var t = _timeNow - _timeStart;  // current time (frames, seconds)  var b = _propStart;             // beginning value  var c = _propDest - _propStart; // change in value  var d = _timeDest - _timeStart; // duration (frames, seconds)  var a = _extra1;                // amplitude (optional - used only on *elastic easing)  var p = _extra2;                // period (optional - used only on *elastic easing)  var s = _extra1;                // overshoot ammount (optional - used only on *back easing)  switch (_animType.toLowerCase()) {  case "linear":    // simple linear tweening - no easing    return c*t/d + b;  case "easeinquad":    // quadratic (t^2) easing in - accelerating from zero velocity    return c*(t/=d)*t + b;  case "easeoutquad":    // quadratic (t^2) easing out - decelerating to zero velocity    return -c *(t/=d)*(t-2) + b;  case "easeinoutquad":    // quadratic (t^2) easing in/out - acceleration until halfway, then deceleration    if ((t/=d/2) < 1) return c/2*t*t + b;    return -c/2 * ((--t)*(t-2) - 1) + b;// This were changed a bit by me (since I'm not using Penner's own Math.* functions)  // So I changed it to call findTweenValue() instead (with some different arguments)  case "easeinbounce":    // bounce (exponentially decaying parabolic bounce) easing in    return c - findTweenValue (0, c, 0, d-t, d, "easeOutBounce") + b;  case "easeoutbounce":    // bounce (exponentially decaying parabolic bounce) easing out    if ((t/=d) < (1/2.75)) {      return c*(7.5625*t*t) + b;    } else if (t < (2/2.75)) {      return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;    } else if (t < (2.5/2.75)) {      return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;    } else {      return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;    }  }};ASSetPropFlags(_global, "findTweenValue", 1, 0);